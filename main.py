import os
from fastapi import FastAPI, UploadFile, Form, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import pandas as pd
import duckdb
from io import BytesIO
import json
from dotenv import load_dotenv
from qdrant_services import embed_text, add_to_qdrant, search_qdrant
from gemini_2_5_flash import ask_gemini
import fitz  # PyMuPDF
from pptx import Presentation  # for .pptx

load_dotenv()

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

def extract_text_from_pdf(pdf_bytes: bytes) -> str:
    try:
        text = ""
        with fitz.open("pdf", pdf_bytes) as doc:
            for page in doc:
                text += page.get_text()
        return text
    except Exception as e:
        raise RuntimeError(f"Failed to extract PDF: {str(e)}")

def extract_text_from_pptx(pptx_bytes: bytes) -> str:
    try:
        text = ""
        with BytesIO(pptx_bytes) as f:
            prs = Presentation(f)
            for slide in prs.slides:
                for shape in slide.shapes:
                    if hasattr(shape, "text"):
                        text += shape.text + " "
        return text
    except Exception as e:
        raise RuntimeError(f"Failed to extract PPTX: {str(e)}")

@app.post("/ask")
async def ask_file(file: UploadFile = File(...), query: str = Form(...)):
    content = await file.read()
    filename = file.filename.lower()

    try:
        if filename.endswith(".csv"):
            # ‚úÖ STRUCTURED
            df_preview = pd.read_csv(BytesIO(content), nrows=5)
            columns = [{"name": col, "type": str(dtype)} for col, dtype in zip(df_preview.columns, df_preview.dtypes)]
            metadata = {"tables": [{"name": "uploaded_table", "columns": columns}]}

            prompt = f"""
You are a helpful data assistant. Given the following table schema:

{json.dumps(metadata, indent=2)}

Generate a JSON function call in this format ONLY:
{{
  "function_call": {{
    "name": "execute_sql_query",
    "arguments": {{
      "query": "<SQL query>"
    }}
  }}
}}

User question: "{query}"
"""
            gemini_response = ask_gemini(prompt)
            print("üîç GEMINI PROMPT:\n", prompt)
            print("üß† GEMINI RAW RESPONSE:\n", gemini_response)

            try:
                if isinstance(gemini_response, dict):
                    tool_call = gemini_response
                else:
                    tool_call = json.loads(gemini_response)
                sql = tool_call["function_call"]["arguments"]["query"]
            except Exception as e:
                tool_call = {"error": f"Gemini JSON parsing failed: {str(e)}"}
                sql = None

            # ‚úÖ EXECUTE SQL with DuckDB
            if sql:
                try:
                    df_full = pd.read_csv(BytesIO(content))
                    con = duckdb.connect()
                    con.register("uploaded_table", df_full)
                    duck_result = con.execute(sql).fetchdf()
                    raw_result = duck_result.to_dict(orient="records")
                except Exception as e:
                    raw_result = {"error": f"DuckDB SQL failed: {str(e)}"}
            else:
                raw_result = {"error": "No valid SQL query generated by Gemini."}

        elif filename.endswith(".pdf"):
            text = extract_text_from_pdf(content)
            chunks = text.split(". ")
            add_to_qdrant(chunks)
            raw_result = search_qdrant(query)
            tool_call = {
                "function_call": {
                    "name": "search_unstructured_data",
                    "arguments": {"query_text": query}
                }
            }

        elif filename.endswith(".pptx"):
            text = extract_text_from_pptx(content)
            chunks = text.split(". ")
            add_to_qdrant(chunks)
            raw_result = search_qdrant(query)
            tool_call = {
                "function_call": {
                    "name": "search_unstructured_data",
                    "arguments": {"query_text": query}
                }
            }

        elif filename.endswith(".txt"):
            text = content.decode("utf-8")
            chunks = text.split(". ")
            add_to_qdrant(chunks)
            raw_result = search_qdrant(query)
            tool_call = {
                "function_call": {
                    "name": "search_unstructured_data",
                    "arguments": {"query_text": query}
                }
            }

        else:
            raise HTTPException(status_code=415, detail="Unsupported file type.")

        # ‚úÖ Gemini Summary
        summary_prompt = f"""
User asked: "{query}"
Data: {raw_result}

Summarize or explain the result in simple language.
"""
        summary = ask_gemini(summary_prompt) or "Summary unavailable."

        return {
            "tool_call": tool_call,
            "result": raw_result,
            "summary": summary
        }

    except Exception as e:
        return {"error": str(e)}
